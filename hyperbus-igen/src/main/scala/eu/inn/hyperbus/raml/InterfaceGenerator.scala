package eu.inn.hyperbus.raml

import java.util.Date
import com.mulesoft.raml1.java.parser.model.datamodel.{StrElement, DataElement, ArrayField, ObjectField}
import com.mulesoft.raml1.java.parser.model.methodsAndResources.{Method, Resource}
import eu.inn.binders.naming._
import eu.inn.hyperbus.transport.api.uri.{TextToken, UriParser}
import org.atteo.evo.inflector.English
import org.slf4j.LoggerFactory
import scala.collection.JavaConversions._
import com.mulesoft.raml1.java.parser.model.api.Api

class DashCaseToUpperSnakeCaseConverter extends BaseConverter(new DashCaseParser) {
  def createBuilder(): IdentifierBuilder = new SnakeUpperCaseBuilder()
}

class DashCaseToPascalCaseConverter extends BaseConverter(new DashCaseParser) {
  def createBuilder(): IdentifierBuilder = new PascalCaseBuilder()
}

case class GeneratorOptions(namespace: String,
                            contentTypePrefix: Option[String] = None,
                            generatorInformation: Boolean = true,
                            defaultImports:Boolean = true,
                            customImports: Option[String] = None
                           )

class InterfaceGenerator(api: Api, options: GeneratorOptions) {
  var log = LoggerFactory.getLogger(getClass)
  val dashToUpper = new DashCaseToUpperSnakeCaseConverter
  val dashToPascal = new DashCaseToPascalCaseConverter

  def generate(): String = {
    val builder = new StringBuilder
    if (options.defaultImports) {
      generateImports(builder)
      builder.append("\n// -------------------- \n")
    }

    options.customImports.foreach { customImports ⇒
      builder.append(customImports)
      builder.append("\n// -------------------- \n")
    }

    if (options.generatorInformation) {
      generateInformation(builder)
      builder.append("\n// -------------------- \n")
    }
    generateTypes(builder)
    builder.append("\n// -------------------- \n")
    generateRequests(builder)
    builder.toString
  }

  protected def generateImports(builder: StringBuilder) = {
    builder.append(
      s"""
         |package ${options.namespace}
         |
         |import eu.inn.binders.annotations.fieldName
         |import eu.inn.hyperbus.model._
         |import eu.inn.hyperbus.model.annotations._
      """.stripMargin
    )
  }

  protected def generateInformation(builder: StringBuilder) = {
    builder.append(
      s"""
        |/*
        | DO NOT EDIT
        | Autogenerated on ${new Date}
        | options: $options
        |*/
        |
      """.stripMargin)
  }

  protected def generateTypes(builder: StringBuilder) = {
    api.types().foreach {
      case obj: ObjectField ⇒
        generateObjectType(builder, obj)

      case strEl: StrElement ⇒
        generateEnumStrElement(builder, strEl)

      case other ⇒
        log.warn(s"Currently $other is not supported in types")
    }
  }

  protected def generateObjectType(builder: StringBuilder, obj: ObjectField) = {
    val bodyResource = api.resources.find { resource ⇒
      resource.methods.exists { method ⇒
        method.method.toLowerCase == "get" &&
        method.responses.exists { response ⇒
          response.body.exists { body ⇒
            body.`type`.contains(obj.name)
          }
        }
      }
    }

    bodyResource match {
      case Some(resource) ⇒
        builder.append(s"""@body("${resource.relativeUri.value}")\n""")
        builder.append(s"case class ${obj.name}(\n")
        generateCaseClassProperties(builder, obj.properties)
        builder.append("\n  ) extends Body\n\n")

      case None ⇒
        builder.append(s"case class ${obj.name}(\n")
        generateCaseClassProperties(builder, obj.properties)
        builder.append("\n  )\n\n")
    }
  }

  protected def generateRequests(builder: StringBuilder) = {
    api.resources.foreach { resource ⇒
      resource.methods.foreach { method ⇒
        method.method match {
          //case "get" ⇒ generateGetRequest(builder, method, resource)
          //case "delete" ⇒ generateDeleteRequest(builder, method, resource)
          case other ⇒ generateOtherRequest(builder, method, resource)
        }
      }
    }
  }

  protected def generateOtherRequest(builder: StringBuilder, method: Method, resource: Resource) = {
    builder.append(s"""@request("${resource.relativeUri.value}")\n""")
    val name = requestClassName(resource.relativeUri.value, method.method)
    builder.append(s"case class $name(\n")
  }

  protected def requestClassName(uriPattern: String, method: String): String = {
    val dashed = UriParser.tokens(uriPattern).collect {
      case TextToken(s) ⇒ English.setMode(s)
    } :+ method mkString "-"
    dashToPascal.convert(dashed)
  }

  protected def generateCaseClassProperties(builder: StringBuilder, properties: Seq[DataElement]) = {
    var isFirst = true
    properties.foreach { property ⇒
      if (isFirst) {
        builder.append("    ")
      }
      else {
        builder.append(",\n    ")
      }
      isFirst = false
      builder.append(property.name)
      builder.append(": ")
      builder.append(property.`type`().headOption.map(mapType).getOrElse("Any"))
    }
  }

  protected def generateEnumStrElement(builder: StringBuilder, el: StrElement) = {
    builder.append(s"object ${el.name} extends Enumeration {\n  type ${el.name} = Value\n")
    var isFirst = true
    el.enum_.foreach { e ⇒
      if (isFirst) {
        builder.append("  ")
      }
      else {
        builder.append(",\n  ")
      }
      isFirst = false
      builder.append(s"""val ${dashToUpper.convert(e)} = Value("$e")""")
    }
    builder.append("\n}\n\n")
  }

  protected def mapType(`type`: String): String = `type` match {
    case "integer" ⇒ "Int"
    case "string" ⇒ "String"
    case other ⇒ other
  }
}
